package main

import (
	"flag"
	"fmt"
	"io"
	"log"
	"net/http"
	"os"
	"path/filepath"
	"regexp"
	"strconv"
	"strings"
	"unicode/utf16"
	"unicode/utf8"
)

type parsedIcon struct {
	name      string
	codePoint string
}

type icon struct {
	name       string
	utf16Value uint16
	utf8Value  []byte
}

func getNerdFontsHtmlBody(url string) (body []byte, error error) {
	resp, err := http.Get(url)
	if err != nil {
		return nil, err
	}

	defer func() {
		err := resp.Body.Close()
		if err != nil {
			error = err
		}
	}()

	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}

	return respBody, nil
}

func parseNerdFontsHtmlBody(htmlBody []byte) ([]parsedIcon, error) {
	const iconNameGroup = "IconName"
	const iconCodePointGroup = "IconCodePoint"
	regexPattern := fmt.Sprintf("<div class=\"class-name\">(?P<%s>.*)</div><div class=\"codepoint\">(?P<%s>.*)</div>", iconNameGroup, iconCodePointGroup)
	regexCompiled, err := regexp.Compile(regexPattern)
	if err != nil {
		return nil, err
	}

	matches := regexCompiled.FindAllSubmatch(htmlBody, -1)
	var parsedIcons []parsedIcon

	for i := 0; i < len(matches); i++ {
		var icon parsedIcon

		for j, name := range regexCompiled.SubexpNames() {
			switch name {
			case iconNameGroup:
				icon.name = string(matches[i][j])
			case iconCodePointGroup:
				icon.codePoint = string(matches[i][j])
			}
		}

		parsedIcons = append(parsedIcons, icon)
	}

	return parsedIcons, nil
}

func convertParsedIconToIcon(parsedIcon *parsedIcon) (*icon, error) {
	parsedUint, err := strconv.ParseUint(parsedIcon.codePoint, 16, 16)
	if err != nil {
		return nil, err
	}

	utf16Value := uint16(parsedUint)
	decodedRunes := utf16.Decode([]uint16{utf16Value})

	var utf8Value []byte
	for _, r := range decodedRunes {
		utf8Value = utf8.AppendRune(utf8Value, r)
	}

	return &icon{parsedIcon.name, utf16Value, utf8Value}, nil
}

// exists returns whether the given file or directory exists
func exists(path string) (bool, error) {
	_, err := os.Stat(path)
	if err == nil {
		return true, nil
	}
	if os.IsNotExist(err) {
		return false, nil
	}
	return false, err
}

func generateCppHeader(filePath string, icons []icon) (error error) {
	dir := filepath.Dir(filePath)
	dirExists, err := exists(dir)
	if !dirExists {
		err := os.Mkdir(dir, os.ModePerm)
		if err != nil {
			return err
		}
	}

	file, err := os.Create(filePath)
	if err != nil {
		return err
	}

	defer func() {
		err := file.Close()
		if err != nil {
			error = err
		}
	}()

	file.WriteString("#pragma once\n\n")

	file.WriteString(fmt.Sprintf("// This file was generated by: '%s'\n\n", strings.Join(os.Args, " ")))

	file.WriteString("namespace NerdFont\n{\n")

	file.WriteString("\tnamespace Utf16\n\t{\n")
	for _, icon := range icons {
		//char16_t
		commentSuffix := fmt.Sprintf("// %s = %s", icon.name, string(icon.utf8Value))

		variableName := strings.ReplaceAll(icon.name, "-", "_")
		variable := fmt.Sprintf("constexpr const char16_t* %s = u\"\\u%x\";", variableName, icon.utf16Value)

		code := fmt.Sprintf("\t\t%s %s\n", variable, commentSuffix)
		file.WriteString(code)
	}
	file.WriteString("\t}\n")

	file.WriteString("\tnamespace Utf8\n\t{\n")
	for _, icon := range icons {
		var utf8String string
		for _, b := range icon.utf8Value {
			utf8String += fmt.Sprintf("\\x%x", b)
		}

		commentSuffix := fmt.Sprintf("// %s = %s", icon.name, string(icon.utf8Value))

		variableName := strings.ReplaceAll(icon.name, "-", "_")
		variable := fmt.Sprintf("constexpr const char* %s = \"%s\";", variableName, utf8String)

		code := fmt.Sprintf("\t\t%s %s\n", variable, commentSuffix)
		file.WriteString(code)
	}
	file.WriteString("\t}\n")

	file.WriteString("}\n")

	return nil
}

func main() {
	var url string
	flag.StringVar(&url, "url", "", "The url to the nerd font cheat sheet")

	var output string
	flag.StringVar(&output, "output", "", "The output filepath should be a cpp header")

	flag.Parse()

	log.Print(url, output)
	log.Print(flag.Args())
	log.Print(os.Args)
	if len(url) == 0 {
		log.Fatal("Provided 'url' should have a length greater than 0")
		return
	}

	if len(output) == 0 {
		log.Fatal("Provided 'output' should have a length greater than 0")
		return
	}

	htmlBody, err := getNerdFontsHtmlBody(url)
	if err != nil {
		log.Fatal(err)
		return
	}

	parsedIcons, err := parseNerdFontsHtmlBody(htmlBody)
	if err != nil {
		log.Fatal(err)
		return
	}

	icons := make([]icon, 0, len(parsedIcons))
	for i := 0; i < len(parsedIcons); i++ {
		icon, err := convertParsedIconToIcon(&parsedIcons[i])
		if err != nil {
			log.Fatal(err)
			return
		}

		icons = append(icons, *icon)
	}

	err = generateCppHeader(output, icons)
	if err != nil {
		log.Fatal(err)
		return
	}

	for i, icon := range icons {
		var utf8String string
		for _, b := range icon.utf8Value {
			utf8String += fmt.Sprintf("%x ", b)
		}

		fmt.Printf("%d %s, utf16:%x, utf8:%s = %s\n", i, icon.name, icon.utf16Value, utf8String, string(icon.utf8Value))
	}
}
